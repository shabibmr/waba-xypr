<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interaction Widget</title>
  <script defer src="https://sdk-cdn.mypurecloud.com/client-apps/2.6.3/purecloud-client-app-sdk.js"></script>
  <script defer src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
    }

    .widget-container {
      height: 100vh;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      background: white;
      overflow: hidden;
    }

    #widgetContent {
      display: flex;
      flex-direction: column;
      flex: 1;
      position: relative;
      min-height: 0;
    }

    /* .active class is no longer needed since it's displayed by default */

    .header {
      background: linear-gradient(135deg, #FF4F1F 0%, #E63C0D 100%);
      color: white;
      padding: 16px 20px;
      flex-shrink: 0;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .header h2 {
      font-size: 16px;
      margin-bottom: 2px;
    }

    .header p {
      font-size: 13px;
      opacity: 0.9;
    }

    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      background: #f9f9f9;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .messages-container::-webkit-scrollbar {
      width: 6px;
    }

    .messages-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .messages-container::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 3px;
    }

    .messages-container::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    .message {
      position: relative;
      max-width: 80%;
      padding: 10px 14px;
      border-radius: 12px;
      margin-bottom: 10px;
      font-size: 14px;
      line-height: 1.4;
      word-wrap: break-word;
      overflow-wrap: break-word;
      animation: slideIn 0.2s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.inbound {
      align-self: flex-start;
      background: white;
      border: 1px solid #e0e0e0;
      border-top-left-radius: 0;
    }

    .message.inbound::before {
      content: '';
      position: absolute;
      top: -1px;
      left: -10px;
      border-width: 10px 10px 0 0;
      border-style: solid;
      border-color: #e0e0e0 transparent transparent transparent;
    }

    .message.inbound::after {
      content: '';
      position: absolute;
      top: 0;
      left: -8px;
      border-width: 9px 9px 0 0;
      border-style: solid;
      border-color: white transparent transparent transparent;
    }

    .message.outbound {
      align-self: flex-end;
      background: #FFF0EB;
      border: 1px solid #FFD3C4;
      border-top-right-radius: 0;
    }

    .message.outbound::before {
      content: '';
      position: absolute;
      top: -1px;
      right: -10px;
      border-width: 10px 0 0 10px;
      border-style: solid;
      border-color: #FFD3C4 transparent transparent transparent;
    }

    .message.outbound::after {
      content: '';
      position: absolute;
      top: 0;
      right: -8px;
      border-width: 9px 0 0 9px;
      border-style: solid;
      border-color: #FFF0EB transparent transparent transparent;
    }

    .message-text {
      margin-bottom: 4px;
    }

    .message-meta {
      font-size: 11px;
      color: #666;
      text-align: right;
      margin-top: 4px;
      opacity: 0.8;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
    }

    .message.inbound .message-meta {
      text-align: left;
      justify-content: flex-start;
    }

    .message-status {
      font-size: 13px;
      display: inline-flex;
    }

    .status-sent {
      color: #999;
    }

    .status-delivered {
      color: #999;
    }

    .status-read {
      color: #53bdeb;
    }

    .status-failed {
      color: #d32f2f;
    }

    .empty-state {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #999;
      font-size: 14px;
      text-align: center;
      padding: 40px 20px;
    }

    .input-container {
      flex-shrink: 0;
      padding: 10px 12px;
      padding-bottom: max(10px, env(safe-area-inset-bottom));
      background: white;
      border-top: 1px solid #e0e0e0;
    }

    .attachment-preview {
      display: none;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      margin-bottom: 8px;
      background: #FFF0EB;
      border-radius: 12px;
      font-size: 13px;
      color: #333;
    }

    .attachment-preview.active {
      display: flex;
    }

    .attachment-preview .file-icon {
      font-size: 18px;
    }

    .attachment-preview .file-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .attachment-preview .file-size {
      font-size: 11px;
      color: #888;
      flex-shrink: 0;
    }

    .attachment-preview .remove-btn {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #999;
      padding: 0 4px;
      line-height: 1;
    }

    .attachment-preview .remove-btn:hover {
      color: #c62828;
    }

    .compose-area {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }

    .btn-attach {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #888;
      width: 40px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: color 0.2s;
      border-radius: 50%;
    }

    .btn-attach:hover {
      color: #FF4F1F;
      background: #f0f0f0;
    }

    .compose-input {
      flex: 1;
      min-width: 0;
      padding: 10px 14px;
      border: 1px solid #ddd;
      border-radius: 24px;
      font-size: 14px;
      font-family: inherit;
      resize: none;
      min-height: 40px;
      max-height: 120px;
      line-height: 1.4;
      outline: none;
      transition: border-color 0.2s;
    }

    .compose-input:focus {
      border-color: #FF4F1F;
    }

    .btn-send {
      background: #FF4F1F;
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .btn-send:hover {
      background: #FF3B05;
      transform: scale(1.05);
    }

    .btn-send:active {
      transform: scale(0.95);
    }

    .btn-send:disabled {
      background: #FFB8A3;
      cursor: not-allowed;
      transform: none;
    }

    /* Media message styles */
    .message-media {
      margin-bottom: 6px;
    }

    .message-media img {
      max-width: 100%;
      border-radius: 8px;
      cursor: pointer;
    }

    .message-media video {
      max-width: 100%;
      border-radius: 8px;
    }

    .message-media audio {
      width: 100%;
    }

    .message-media .doc-link {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      text-decoration: none;
      color: #1a73e8;
      font-size: 13px;
    }

    .message-media .doc-link:hover {
      background: rgba(0, 0, 0, 0.08);
    }

    /* Location message styles */
    .message-location {
      margin-bottom: 6px;
      border-radius: 8px;
      overflow: hidden;
    }

    .message-location a {
      display: block;
      text-decoration: none;
      color: inherit;
    }

    .message-location img {
      width: 100%;
      max-height: 150px;
      object-fit: cover;
      display: block;
    }

    .message-location .location-info {
      padding: 6px 8px;
      font-size: 13px;
      background: rgba(0, 0, 0, 0.03);
    }

    .message-location .location-info .loc-name {
      font-weight: 600;
    }

    .message-location .location-info .loc-address {
      color: #666;
      font-size: 12px;
    }

    /* Sticker styles */
    .message-sticker {
      margin-bottom: 4px;
    }

    .message-sticker img {
      max-width: 160px;
      max-height: 160px;
    }

    .message.sticker-msg {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      padding: 4px !important;
    }

    /* Contact card styles */
    .message-contacts {
      margin-bottom: 6px;
    }

    .contact-card {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.04);
      border-radius: 8px;
      margin-bottom: 4px;
      font-size: 13px;
    }

    .contact-card .contact-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: #FF4F1F;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      flex-shrink: 0;
    }

    .contact-card .contact-name {
      font-weight: 500;
    }

    .contacts-overflow {
      font-size: 12px;
      color: #888;
      padding: 2px 10px;
    }

    /* Interactive reply styles */
    .message-interactive {
      margin-bottom: 6px;
      padding: 8px 12px;
      border-left: 3px solid #FF4F1F;
      background: rgba(255, 79, 31, 0.06);
      border-radius: 0 8px 8px 0;
      font-size: 13px;
    }

    .message-interactive .interactive-label {
      font-size: 11px;
      color: #FF4F1F;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 2px;
    }

    .message-interactive .interactive-title {
      font-weight: 500;
    }

    .loading {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-size: 14px;
    }

    .error {
      margin: 20px;
      background: #ffebee;
      color: #c62828;
      padding: 16px;
      border-radius: 8px;
      font-size: 14px;
    }

    .error .error-content {
      text-align: center;
    }

    .error .attempts {
      font-size: 12px;
      color: #999;
      margin-top: 8px;
    }

    .error .retry-btn,
    .error .reset-btn {
      margin: 12px 4px 0 4px;
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .error .retry-btn {
      background: #FF4F1F;
      color: white;
    }

    .error .retry-btn:hover {
      background: #FF3B05;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(255, 79, 31, 0.3);
    }

    .error .reset-btn {
      background: #666;
      color: white;
    }

    .error .reset-btn:hover {
      background: #555;
      transform: translateY(-1px);
    }

    .error .help-text {
      font-size: 12px;
      color: #999;
      margin-top: 12px;
      font-style: italic;
    }

    .typing-indicator {
      display: none;
      align-self: flex-start;
      padding: 10px 14px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      margin-bottom: 12px;
    }

    .typing-indicator.active {
      display: block;
    }

    .typing-indicator span {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #999;
      margin: 0 2px;
      animation: typing 1.4s infinite;
    }

    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-indicator span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing {

      0%,
      60%,
      100% {
        opacity: 0.3;
        transform: translateY(0);
      }

      30% {
        opacity: 1;
        transform: translateY(-8px);
      }
    }

    .scroll-bottom-btn {
      position: absolute;
      right: 16px;
      bottom: 74px;
      /* default above single line input */
      width: 36px;
      height: 36px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #666;
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: all 0.2s ease;
      z-index: 100;
    }

    .scroll-bottom-btn.visible {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .scroll-bottom-btn:hover {
      background: #f5f5f5;
      color: #333;
    }

    .scroll-bottom-btn svg {
      width: 20px;
      height: 20px;
    }

    /* ‚îÄ‚îÄ Responsive: small screens ‚îÄ‚îÄ */
    @media (max-width: 480px) {
      .header {
        padding: 12px 14px;
      }

      .header h2 {
        font-size: 15px;
      }

      .header p {
        font-size: 12px;
      }

      .messages-container {
        padding: 10px;
      }

      .message {
        max-width: 88%;
        font-size: 13px;
        padding: 8px 12px;
      }

      .compose-area {
        gap: 6px;
      }

      .compose-input {
        padding: 8px 12px;
        font-size: 13px;
        min-height: 36px;
      }

      .btn-send {
        width: 36px;
        height: 36px;
        font-size: 16px;
      }

      .btn-attach {
        width: 36px;
        height: 36px;
        font-size: 18px;
      }

      .input-container {
        padding: 8px 10px;
        padding-bottom: max(8px, env(safe-area-inset-bottom));
      }
    }

    @media (max-width: 360px) {
      .message {
        max-width: 92%;
      }

      .btn-attach {
        display: none;
      }
    }
  </style>
</head>

<body>
  <div class="widget-container">
    <!-- Header -->
    <div class="header">
      <h2 id="customerName">Customer</h2>
      <p id="waNumber">Loading...</p>
    </div>

    <!-- Loading State (Now absolute so it doesn't shift layout) -->
    <div id="loading" class="loading"
      style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.8); z-index: 10;">
      Loading conversation...
    </div>

    <!-- Error State -->
    <div id="error" class="error" style="display: none;"></div>

    <!-- Main Chat Interface -->
    <div id="widgetContent">
      <!-- Messages Area -->
      <div class="messages-container" id="messagesContainer">
        <div class="empty-state" id="emptyState">
          No messages yet. Start the conversation!
        </div>
        <div class="typing-indicator" id="typingIndicator">
          <span></span><span></span><span></span>
        </div>
      </div>

      <button id="scrollBottomBtn" class="scroll-bottom-btn" title="Scroll to bottom">
        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"
          stroke-linejoin="round">
          <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
      </button>

      <!-- Input Area -->
      <div class="input-container">
        <!-- Attachment preview -->
        <div class="attachment-preview" id="attachmentPreview">
          <span class="file-icon" id="attachFileIcon">üìé</span>
          <span class="file-name" id="attachFileName"></span>
          <span class="file-size" id="attachFileSize"></span>
          <button class="remove-btn" id="removeAttachBtn" title="Remove">‚úï</button>
        </div>
        <!-- Hidden file input -->
        <input type="file" id="fileInput" style="display:none"
          accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.csv,.zip" />
        <div class="compose-area">
          <button class="btn-attach" id="attachBtn" title="Attach file">
            üìé
          </button>
          <textarea id="customMessageInput" class="compose-input" placeholder="Type a message..." rows="1"></textarea>
          <button class="btn-send" id="sendBtn" title="Send message">
            ‚û§
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration - Dynamic URL resolution for iframe embedding
    const API_BASE_URL = window.WIDGET_CONFIG?.apiUrl || '/widget/api';

    // Extract Genesys-interpolated query params
    let urlParams = new URLSearchParams(window.location.search);

    // Genesys context from URL interpolation
    // Derive environment from env param, gcHostOrigin, or gcTargetEnv
    function deriveEnvironment() {
      const env = urlParams.get('env'); // {{pcEnvironment}} e.g. aps1.pure.cloud
      if (env) return env;
      // Extract from gcHostOrigin: https://apps.aps1.pure.cloud ‚Üí aps1.pure.cloud
      const origin = urlParams.get('gcHostOrigin') || urlParams.get('origin');
      if (origin) {
        const match = origin.match(/apps\.(.+)/);
        if (match) return match[1];
      }
      return null;
    }

    let genesysContext = {
      conversationId: urlParams.get('conversationId'),  // {{pcConversationId}}
      langTag: urlParams.get('langTag'),          // {{pcLangTag}}
      environment: deriveEnvironment(),              // {{pcEnvironment}} or derived
      hostOrigin: urlParams.get('gcHostOrigin') || urlParams.get('origin'),
      targetEnv: urlParams.get('gcTargetEnv'),      // {{gcTargetEnv}}
      usePopupAuth: urlParams.get('usePopupAuth'),     // {{pcUsePopupAuth}}
    };

    // -- OAuth Implicit Grant Flow --
    let gcToken = null;

    // OAuth redirect loop protection
    const OAUTH_MAX_ATTEMPTS = 3;
    const OAUTH_TIMEOUT_MS = 30000; // 30 seconds
    const OAUTH_ATTEMPT_KEY = 'gc.oauth.attempts';
    const OAUTH_TIMESTAMP_KEY = 'gc.oauth.timestamp';
    const OAUTH_STATE_KEY = 'gc.oauth.state';

    // Get OAuth attempt count from sessionStorage
    function getOAuthAttempts() {
      try {
        const count = sessionStorage.getItem(OAUTH_ATTEMPT_KEY);
        return count ? parseInt(count, 10) : 0;
      } catch (e) {
        // sessionStorage unavailable (private browsing)
        return 0;
      }
    }

    // Set OAuth attempt count in sessionStorage
    function setOAuthAttempts(count) {
      try {
        sessionStorage.setItem(OAUTH_ATTEMPT_KEY, count.toString());
        sessionStorage.setItem(OAUTH_TIMESTAMP_KEY, Date.now().toString());
      } catch (e) {
        // sessionStorage unavailable - gracefully degrade
        console.warn('[Widget] sessionStorage unavailable, OAuth attempt tracking disabled');
      }
    }

    // Increment OAuth attempt counter (with staleness check)
    function incrementOAuthAttempts() {
      try {
        const currentCount = getOAuthAttempts();
        const timestamp = sessionStorage.getItem(OAUTH_TIMESTAMP_KEY);

        // Reset if attempts are stale (>5 minutes old)
        if (timestamp) {
          const age = Date.now() - parseInt(timestamp, 10);
          if (age > 5 * 60 * 1000) {
            setOAuthAttempts(1);
            return 1;
          }
        }

        const newCount = currentCount + 1;
        setOAuthAttempts(newCount);
        return newCount;
      } catch (e) {
        return 1; // Fail-open
      }
    }

    // Clear OAuth attempt counter on success
    function clearOAuthAttempts() {
      try {
        sessionStorage.removeItem(OAUTH_ATTEMPT_KEY);
        sessionStorage.removeItem(OAUTH_TIMESTAMP_KEY);
        sessionStorage.removeItem(OAUTH_STATE_KEY);
      } catch (e) {
        // sessionStorage unavailable - ignore
      }
    }

    // Check if max OAuth attempts exceeded (circuit breaker)
    function isOAuthMaxAttemptsExceeded() {
      try {
        return getOAuthAttempts() >= OAUTH_MAX_ATTEMPTS;
      } catch (e) {
        return false; // Fail-open if sessionStorage unavailable
      }
    }

    // Retrieve stored OAuth error from previous attempt
    function getStoredOAuthError() {
      try {
        const error = sessionStorage.getItem(OAUTH_STATE_KEY);
        sessionStorage.removeItem(OAUTH_STATE_KEY);
        return error;
      } catch (e) {
        return null;
      }
    }

    async function ensureAuthenticated() {
      // ‚îÄ‚îÄ‚îÄ STEP 1: Check max attempts (circuit breaker) ‚îÄ‚îÄ‚îÄ
      if (isOAuthMaxAttemptsExceeded()) {
        showError(
          'Maximum authentication attempts exceeded. This may indicate a configuration issue.',
          { showReset: true }
        );
        return false;
      }

      // ‚îÄ‚îÄ‚îÄ STEP 2: Process OAuth callback (hash contains token) ‚îÄ‚îÄ‚îÄ
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const token = hashParams.get('access_token');
      const error = hashParams.get('error');

      if (token) {
        try {
          // Store token in sessionStorage
          sessionStorage.setItem('gc.token', token);
          gcToken = token;

          // Clear hash from URL
          window.location.hash = '';

          // Restore original search params from state
          const state = hashParams.get('state');
          if (state) {
            const search = decodeURIComponent(state);
            window.history.replaceState(null, '', window.location.pathname + search);

            // Re-parse URL params
            urlParams = new URLSearchParams(search);
            genesysContext.conversationId = urlParams.get('conversationId');
            genesysContext.langTag = urlParams.get('langTag');
            genesysContext.environment = urlParams.get('env') || deriveEnvironment();
            genesysContext.hostOrigin = urlParams.get('gcHostOrigin') || urlParams.get('origin');
            genesysContext.targetEnv = urlParams.get('gcTargetEnv');
            genesysContext.usePopupAuth = urlParams.get('usePopupAuth');
          }

          // Fetch user info
          try {
            const region = genesysContext.environment || 'mypurecloud.com';
            const userRes = await fetch(`https://api.${region}/api/v2/users/me`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (userRes.ok) {
              const userData = await userRes.json();
              sessionStorage.setItem('gc.userId', userData.id);
              window.gcUserId = userData.id;
              console.log('[Widget] User authenticated:', userData.id);
            }
          } catch (err) {
            console.error('[Widget] Error fetching user info:', err);
            // Non-fatal - continue with auth
          }

          // SUCCESS - Clear attempt counter
          clearOAuthAttempts();
          return true;

        } catch (err) {
          console.error('[Widget] Token processing error:', err);
          showError(
            `Failed to process authentication: ${err.message}`,
            { showRetry: true }
          );
          return false;
        }
      }

      // ‚îÄ‚îÄ‚îÄ STEP 3: Handle OAuth error callback ‚îÄ‚îÄ‚îÄ
      if (error) {
        console.error('[Widget] OAuth Error:', error);
        const errorDesc = hashParams.get('error_description') || error;
        showError(
          `Authentication failed: ${errorDesc}`,
          { showRetry: true }
        );
        return false;
      }

      // ‚îÄ‚îÄ‚îÄ STEP 4: Check for existing token in sessionStorage ‚îÄ‚îÄ‚îÄ
      const storedToken = sessionStorage.getItem('gc.token');
      if (storedToken) {
        gcToken = storedToken;

        // Fetch user ID if not already stored
        const storedUserId = sessionStorage.getItem('gc.userId');
        if (!storedUserId) {
          try {
            const region = genesysContext.environment || 'mypurecloud.com';
            const userRes = await fetch(`https://api.${region}/api/v2/users/me`, {
              headers: { 'Authorization': `Bearer ${gcToken}` }
            });
            if (userRes.ok) {
              const userData = await userRes.json();
              sessionStorage.setItem('gc.userId', userData.id);
              window.gcUserId = userData.id;
              console.log('[Widget] User ID fetched:', userData.id);
            }
          } catch (err) {
            console.error('[Widget] Error fetching user info:', err);
          }
        } else {
          window.gcUserId = storedUserId;
        }

        return true; // Already authenticated
      }

      // ‚îÄ‚îÄ‚îÄ STEP 5: Initiate OAuth flow ‚îÄ‚îÄ‚îÄ

      // Increment attempt counter BEFORE redirecting
      const newAttemptCount = incrementOAuthAttempts();
      console.log(`[Widget] OAuth attempt ${newAttemptCount}/${OAUTH_MAX_ATTEMPTS}`);

      try {
        // Fetch widget configuration
        const configUrl = API_BASE_URL.replace('/api', '/config');
        const configRes = await fetch(configUrl);

        if (!configRes.ok) {
          throw new Error('Failed to fetch widget configuration');
        }

        const configData = await configRes.json();
        const clientId = configData.genesysClientId;
        const region = genesysContext.environment || configData.genesysRegion || 'mypurecloud.com';

        // VALIDATE CLIENT ID
        if (!clientId) {
          showError(
            'Widget not configured: Missing GENESYS_WIDGET_CLIENT_ID. Please check environment configuration.',
            { showRetry: false }
          );
          return false;
        }

        // Build OAuth URL
        const redirectUri = window.location.origin + window.location.pathname;
        const state = encodeURIComponent(window.location.search);
        const loginUrl = `https://login.${region}/oauth/authorize?client_id=${clientId}&response_type=token&redirect_uri=${encodeURIComponent(redirectUri)}&state=${state}`;

        console.log('[Widget] Redirecting to OAuth:', loginUrl);

        // Set timeout warning (visual feedback before redirect)
        setTimeout(() => {
          console.warn('[Widget] OAuth timeout - if this persists, check network or OAuth configuration');
        }, OAUTH_TIMEOUT_MS);

        // Redirect to OAuth provider
        document.getElementById('loading').style.display = 'flex';
        document.getElementById('loading').textContent = 'Redirecting to authentication...';
        window.location.replace(loginUrl);

        // Return never-resolving promise (page navigates away)
        return new Promise(() => {});

      } catch (err) {
        console.error('[Widget] OAuth initiation error:', err);
        showError(
          `Configuration error: ${err.message}`,
          { showRetry: true }
        );
        return false;
      }
    }

    // Derive Socket.IO URL from current origin (route through api-gateway)
    const SOCKET_URL = window.WIDGET_CONFIG?.socketUrl || window.location.origin;

    let conversationId = null;
    let tenantId = null;
    let waId = null;
    let integrationId = null;
    let communicationId = null;
    let lastMessageId = null;
    let pollTimer = null;
    let socket = null;
    let useSocketIO = true;
    let selectedFile = null;  // Currently attached file
    let myClientApp = null;

    // Pagination state
    let currentOffset = 0;
    const baseLimit = 30;
    let isLoadingHistory = false;
    let hasMoreHistory = true;

    // Initialize Genesys Client App SDK
    function initClientApp() {
      try {
        const pcEnvironment = genesysContext.environment;
        if (pcEnvironment && window.purecloud?.apps?.ClientApp) {
          myClientApp = new window.purecloud.apps.ClientApp({
            pcEnvironment: pcEnvironment
          });
          console.log('[Widget] Client App SDK initialized for env:', pcEnvironment);
        } else {
          console.warn('[Widget] Client App SDK not available or no pcEnvironment provided');
        }
      } catch (err) {
        console.error('[Widget] Client App SDK init error:', err);
      }
    }

    // Resolve tenant ID from conversation ID via backend
    async function resolveTenant(conversationId) {
      try {
        const response = await fetch(`${API_BASE_URL}/resolve-tenant?conversationId=${conversationId}`);
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.error || 'Failed to resolve tenant');
        }
        const data = await response.json();
        return data.tenantId || data.id; // Check both for compatibility
      } catch (error) {
        console.error('[Widget] Tenant resolution error:', error);
        throw error;
      }
    }

    // Initialize widget
    async function initWidget() {
      try {
        // Authenticate first
        const authenticated = await ensureAuthenticated();
        if (!authenticated) return; // Halt if redirecting or errored

        // Initialize Genesys Client App SDK first
        initClientApp();

        // Get conversation ID from Genesys-interpolated URL
        conversationId = genesysContext.conversationId;

        if (!conversationId) {
          showError('Missing conversationId parameter. Ensure the Genesys widget URL uses {{pcConversationId}}.');
          return;
        }

        // Validate and Resolve Tenant ID & Fetch Data
        try {
          const loadingEl = document.getElementById('loading');
          loadingEl.style.display = 'flex';
          loadingEl.textContent = 'Initializing...';

          // Add timeout to init endpoint
          const initController = new AbortController();
          const initTimeout = setTimeout(() => initController.abort(), 10000); // 10s timeout

          let initRes;
          try {
            // Use unified init endpoint
            initRes = await fetch(`${API_BASE_URL}/init?conversationId=${conversationId}`, {
              signal: initController.signal
            });
            clearTimeout(initTimeout);

            if (!initRes.ok) {
              const err = await initRes.json();
              throw new Error(err.error || 'Failed to initialize widget data');
            }
          } catch (fetchError) {
            clearTimeout(initTimeout);

            if (fetchError.name === 'AbortError') {
              showError(
                'Widget initialization timed out. The server may be slow or unavailable. Please try again.',
                { showRetry: true }
              );
              return;
            }
            throw fetchError;
          }

          const initData = await initRes.json();
          tenantId = initData.tenantId;
          console.log('[Widget] Resolved tenant:', tenantId);

          // Process Customer Data
          if (initData.customerData && !initData.customerData.error) {
            const data = initData.customerData;
            document.getElementById('customerName').textContent = data.contactName || 'WhatsApp Customer';
            document.getElementById('waNumber').textContent = data.waId || 'Unknown';

            waId = data.waId;
            integrationId = data.integrationId || null;
            communicationId = data.communicationId || null;
            console.log('[Widget] Conversation context:', { waId, integrationId, communicationId });
          } else {
            console.error('Error loading customer data:', initData.customerData?.error);
            // Wait, if we can't get customer data (like waId), the widget is useless. 
            // We should throw an error to trigger showError().
            throw new Error(initData.customerData?.error?.message || initData.customerData?.error || 'Conversation not found. The customer has not sent a message within 24 hours or the session expired.');
          }

          // Process Message History
          if (initData.messageHistory && !initData.messageHistory.error) {
            const data = initData.messageHistory;
            // Update tenantId from state-manager response if resolved
            if (data.tenant_id && data.tenant_id !== 'default') {
              tenantId = data.tenant_id;
            }

            const newestId = data.messages[0]?.id ?? null;
            lastMessageId = newestId;

            // Initialize pagination
            currentOffset = data.messages.length;
            if (data.messages.length < baseLimit) {
              hasMoreHistory = false;
            }

            const container = document.getElementById('messagesContainer');
            const emptyState = document.getElementById('emptyState');
            const typingIndicator = document.getElementById('typingIndicator');

            // Clear existing messages (but keep typing indicator)
            const messages = container.querySelectorAll('.message');
            messages.forEach(msg => msg.remove());

            if (data.messages.length === 0) {
              emptyState.style.display = 'flex';
            } else {
              emptyState.style.display = 'none';

              // Render messages in chronological order (oldest first)
              const reversed = [...data.messages].reverse();
              reversed.forEach(msg => {
                const msgDiv = createMessageElement(msg);
                // Insert before typing indicator
                container.insertBefore(msgDiv, typingIndicator);
              });

              scrollToBottom();
            }
          } else {
            console.error('Error loading message history:', initData.messageHistory?.error);
          }

        } catch (error) {
          showError(`Configuration Error: ${error.message}`, { showRetry: true });
          return;
        }

        // Initialize Socket.IO connection preemptively while loading data
        initSocket();

        document.getElementById('loading').style.display = 'none';

        // Show the main widget interface
        document.getElementById('widgetContent').classList.add('active');

        // Focus on input
        document.getElementById('customMessageInput').focus();

        // Notify Genesys that widget has finished loading
        if (myClientApp) {
          myClientApp.lifecycle.bootstrapped();
          console.log('[Widget] Notified Genesys: bootstrapped');
        }
      } catch (error) {
        showError('Failed to initialize widget: ' + error.message, { showRetry: true });
      }
    }

    // Load customer data
    async function loadCustomerData() {
      try {
        const response = await fetch(
          `${API_BASE_URL}/conversation/${conversationId}`,
          {
            headers: {
              'X-Tenant-ID': tenantId
            }
          }
        );

        if (!response.ok) throw new Error('Failed to load customer data');

        const data = await response.json();

        // Update UI
        document.getElementById('customerName').textContent = data.contactName || 'WhatsApp Customer';
        document.getElementById('waNumber').textContent = data.waId || 'Unknown';

        waId = data.waId;
        integrationId = data.integrationId || null;
        communicationId = data.communicationId || null;
        console.log('[Widget] Conversation context:', { waId, integrationId, communicationId });

        // Note: loadMessageHistory is now called in parallel from initWidget
      } catch (error) {
        console.error('Error loading customer data:', error);
        throw error;
      }
    }

    // Load message history; returns true if new messages were rendered (used by polling and reload)
    async function loadMessageHistory({ silent = false } = {}) {
      try {
        const limitToFetch = Math.max(currentOffset || baseLimit, baseLimit);
        const response = await fetch(
          `${API_BASE_URL}/conversation/${conversationId}/history?limit=${limitToFetch}`,
          {
            headers: {
              'X-Tenant-ID': tenantId
            }
          }
        );

        if (!response.ok) throw new Error('Failed to load messages');

        const data = await response.json();

        // Update tenantId from state-manager response if resolved
        if (data.tenant_id && data.tenant_id !== 'default') {
          tenantId = data.tenant_id;
        }

        // Skip re-render if nothing changed
        const newestId = data.messages[0]?.id ?? null;
        if (silent && newestId === lastMessageId) return false;
        lastMessageId = newestId;

        const container = document.getElementById('messagesContainer');
        const emptyState = document.getElementById('emptyState');
        const typingIndicator = document.getElementById('typingIndicator');

        // Remember scroll position before re-render
        const wasNearBottom = isNearBottom();

        // Clear existing messages (but keep typing indicator)
        const messages = container.querySelectorAll('.message');
        messages.forEach(msg => msg.remove());

        if (data.messages.length === 0) {
          emptyState.style.display = 'flex';
          return true;
        }

        emptyState.style.display = 'none';

        // Render messages in chronological order (oldest first)
        const reversed = [...data.messages].reverse();
        reversed.forEach(msg => {
          const msgDiv = createMessageElement(msg);
          // Insert before typing indicator
          container.insertBefore(msgDiv, typingIndicator);
        });

        // Auto-scroll: always on first load, on silent updates only if user was near bottom
        if (!silent || wasNearBottom) {
          scrollToBottom(silent);
        }

        return true;
      } catch (error) {
        console.error('Error loading message history:', error);
        return false;
      }
    }

    // Fetch older messages when scrolling up
    async function fetchOlderMessages() {
      if (isLoadingHistory || !hasMoreHistory || !conversationId) return;
      isLoadingHistory = true;

      try {
        const response = await fetch(
          `${API_BASE_URL}/conversation/${conversationId}/history?limit=${baseLimit}&offset=${currentOffset}`,
          { headers: { 'X-Tenant-ID': tenantId } }
        );

        if (!response.ok) throw new Error('Failed to load older messages');
        const data = await response.json();
        const messages = data.messages || [];

        if (messages.length < baseLimit) {
          hasMoreHistory = false;
        }

        if (messages.length === 0) {
          isLoadingHistory = false;
          return;
        }

        currentOffset += messages.length;

        const container = document.getElementById('messagesContainer');
        const firstMessage = container.querySelector('.message');
        const oldScrollHeight = container.scrollHeight;

        const reversed = [...messages].reverse();
        reversed.forEach(msg => {
          const msgDiv = createMessageElement(msg);
          if (firstMessage) {
            container.insertBefore(msgDiv, firstMessage);
          } else {
            const typingIndicator = document.getElementById('typingIndicator');
            container.insertBefore(msgDiv, typingIndicator);
          }
        });

        const newScrollHeight = container.scrollHeight;
        container.scrollTop = container.scrollTop + (newScrollHeight - oldScrollHeight);

      } catch (error) {
        console.error('Error fetching older messages:', error);
      } finally {
        isLoadingHistory = false;
      }
    }

    // Check if user is near the bottom of the chat (within threshold)
    function isNearBottom(threshold = 150) {
      const container = document.getElementById('messagesContainer');
      if (!container) return true;
      const distanceToBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
      return distanceToBottom <= threshold;
    }

    // Scroll to bottom of messages
    function scrollToBottom(smooth = false) {
      const container = document.getElementById('messagesContainer');
      if (smooth) {
        container.scrollTo({
          top: container.scrollHeight,
          behavior: 'smooth'
        });
      } else {
        container.scrollTop = container.scrollHeight;
      }
    }

    // Initialize Socket.IO connection
    async function initSocket() {
      if (!useSocketIO) {
        console.warn('[Widget] Socket.IO disabled, using polling fallback');
        startPolling();
        return;
      }

      try {
        let socketToken = null;
        try {
          const res = await fetch(`${API_BASE_URL}/socket-token?tenantId=${tenantId}&agentUserId=${window.gcUserId || ''}`);
          if (res.ok) {
            const data = await res.json();
            socketToken = data.token;
          } else {
            console.warn('[Widget] Failed to fetch socket token', res.status);
          }
        } catch (e) {
          console.error('[Widget] Error fetching socket token', e);
        }

        socket = io(SOCKET_URL, {
          transports: ['websocket', 'polling'],
          auth: {
            token: socketToken
          }
        });

        socket.on('connect', () => {
          console.log('[Widget] Socket connected:', socket.id);
        });

        socket.on('connect_error', (error) => {
          console.error('[Widget] Socket connection error:', error.message);
          if (error.message.includes('Authentication')) {
            console.warn('[Widget] Socket auth failed, falling back to polling');
            useSocketIO = false;
            socket.disconnect();
            startPolling();
          }
        });

        socket.on('disconnect', (reason) => {
          console.log('[Widget] Socket disconnected:', reason);
        });

        // Listen for new messages
        socket.on('new_message', (message) => {
          if (message.conversation_id === conversationId) {
            console.log('[Widget] Received new message:', message.id);
            // Parse rich media from metadata
            let media = null;
            if (message.metadata) {
              try {
                const meta = typeof message.metadata === 'string' ? JSON.parse(message.metadata) : message.metadata;
                const msgType = meta.messageType || null;
                if (meta.type === 'location' || msgType === 'location') {
                  media = { type: 'location', latitude: meta.latitude, longitude: meta.longitude, name: meta.name, address: meta.address, mapsUrl: meta.mapsUrl };
                } else if (meta.type === 'contacts' || msgType === 'contacts') {
                  media = { type: 'contacts', contacts: meta.contacts || [] };
                } else if (meta.type === 'interactive' || msgType === 'interactive' || msgType === 'button') {
                  media = { type: 'interactive', interactiveType: meta.interactiveType, buttonReply: meta.buttonReply, listReply: meta.listReply };
                } else if (msgType === 'sticker' && meta.mediaUrl) {
                  media = { type: 'sticker', url: meta.mediaUrl };
                } else if (meta.mediaUrl) {
                  let mtype = 'document';
                  const mime = meta.mediaMimeType || '';
                  if (mime.startsWith('image/')) mtype = 'image';
                  else if (mime.startsWith('video/')) mtype = 'video';
                  else if (mime.startsWith('audio/')) mtype = 'audio';
                  media = { url: meta.mediaUrl, type: mtype, mimeType: mime };
                }
              } catch (e) { /* ignore parse errors */ }
            }
            addMessageToUI({
              id: message.id,
              direction: message.direction ? message.direction.toLowerCase() : 'unknown',
              text: message.text || '',
              media: media,
              timestamp: message.created_at || new Date().toISOString(),
              status: message.status
            });
            lastMessageId = message.id;
          }
        });

        // Listen for status updates
        socket.on('status_update', (data) => {
          console.log('[Widget] Message status update:', data.messageId, data.status);
          const msgEl = document.querySelector(`.message[data-message-id="${data.messageId}"]`);
          if (msgEl) {
            const statusSpan = msgEl.querySelector('.message-status');
            if (statusSpan) {
              let statusHtml = '‚úì';
              let statusClass = 'status-sent';

              switch (data.status) {
                case 'read':
                  statusHtml = '‚úì‚úì';
                  statusClass = 'status-read';
                  break;
                case 'delivered':
                  statusHtml = '‚úì‚úì';
                  statusClass = 'status-delivered';
                  break;
                case 'failed':
                  statusHtml = '‚ùå';
                  statusClass = 'status-failed';
                  break;
              }

              statusSpan.innerHTML = statusHtml;
              statusSpan.className = `message-status ${statusClass}`;
            }
          }
        });

        // Listen for conversation updates
        socket.on('conversation_update', (conversation) => {
          if (conversation.id === conversationId) {
            console.log('[Widget] Conversation update:', conversation);
            // Update header info if needed
          }
        });

      } catch (error) {
        console.error('[Widget] Failed to initialize socket:', error);
        useSocketIO = false;
        startPolling();
      }
    }

    // Fallback polling for when socket fails
    function startPolling() {
      // stopPolling();
      // pollTimer = setInterval(async () => {
      //   await loadMessageHistory({ silent: true });
      // }, 3000);
    }

    function stopPolling() {
      if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
      }
    }

    // Show error with optional retry buttons
    function showError(message, options = {}) {
      const { showRetry = false, showReset = false } = options;

      document.getElementById('loading').style.display = 'none';
      const errorDiv = document.getElementById('error');

      const attempts = getOAuthAttempts();

      let html = `<div class="error-content">
        <p><strong>Authentication Error</strong></p>
        <p>${message}</p>`;

      if (attempts > 0) {
        html += `<p class="attempts">Attempts: ${attempts}/${OAUTH_MAX_ATTEMPTS}</p>`;
      }

      if (showRetry) {
        html += '<button onclick="retryAuth()" class="retry-btn">Retry Authentication</button>';
      }

      if (showReset) {
        html += '<button onclick="resetAuth()" class="reset-btn">Reset & Try Again</button>';
        html += '<p class="help-text">Too many failed attempts. Reset will clear the counter.</p>';
      }

      html += '</div>';

      errorDiv.innerHTML = html;
      errorDiv.style.display = 'block';
    }

    // Global retry function (called by retry button)
    window.retryAuth = function() {
      window.location.reload();
    };

    // Global reset function (called by reset button)
    window.resetAuth = function() {
      clearOAuthAttempts();
      window.location.reload();
    };

    // Send custom free-text or media message via Genesys
    async function sendCustomMessage() {
      const input = document.getElementById('customMessageInput');
      const text = input.value.trim();

      // Need text or a file
      if (!text && !selectedFile) return;

      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;

      const hasFile = !!selectedFile;

      // Optimistically add message to UI
      addMessageToUI({
        direction: 'outbound',
        text: text || (hasFile ? selectedFile.name : ''),
        media: hasFile ? { url: URL.createObjectURL(selectedFile), type: selectedFile.type, localPreview: true } : null,
        timestamp: new Date().toISOString()
      });

      try {
        let mediaUrl = null;
        let mediaType = null;

        // 1. Upload Media if present
        if (hasFile) {
          const formData = new FormData();
          formData.append('file', selectedFile);

          const uploadRes = await fetch(`${API_BASE_URL}/upload-media`, {
            method: 'POST',
            headers: {
              'X-Tenant-ID': tenantId,
              ...(gcToken && { 'X-Genesys-Auth-Token': gcToken }),
              ...(window.gcUserId && { 'X-Genesys-User-ID': window.gcUserId })
            },
            body: formData
          });

          if (!uploadRes.ok) {
            throw new Error('Failed to upload media');
          }

          const uploadData = await uploadRes.json();
          mediaUrl = uploadData.url;
          mediaType = uploadData.mimeType;

          removeAttachment();
        }

        // 2. Send Message
        const response = await fetch(`${API_BASE_URL}/send-message`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Tenant-ID': tenantId,
            ...(gcToken && { 'X-Genesys-Auth-Token': gcToken }),
            ...(window.gcUserId && { 'X-Genesys-User-ID': window.gcUserId })
          },
          body: JSON.stringify({
            conversationId,
            waId,
            text,
            mediaUrl,
            mediaType,
            integrationId
          })
        });

        if (!response.ok) {
          const err = await response.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to send message');
        }

        input.value = '';
        input.style.height = 'auto';

        // Reload to get the actual message from server
        setTimeout(() => loadMessageHistory({ silent: true }), 1000);
      } catch (error) {
        console.error(error);
        alert('‚ùå Failed to send: ' + error.message);
        // Reload to remove optimistic message
        await loadMessageHistory();
      } finally {
        sendBtn.disabled = false;
      }
    }

    // File selection handler
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      // Validate size (16 MB)
      if (file.size > 16 * 1024 * 1024) {
        alert('File too large. Maximum size is 16 MB.');
        event.target.value = '';
        return;
      }

      selectedFile = file;

      // Show preview bar
      const preview = document.getElementById('attachmentPreview');
      document.getElementById('attachFileIcon').textContent = getFileIcon(file.type);
      document.getElementById('attachFileName').textContent = file.name;
      document.getElementById('attachFileSize').textContent = formatFileSize(file.size);
      preview.classList.add('active');
    }

    // Remove attached file
    function removeAttachment() {
      selectedFile = null;
      document.getElementById('fileInput').value = '';
      document.getElementById('attachmentPreview').classList.remove('active');
    }

    // Resolve MIME to media type string
    function resolveMediaType(mimeType) {
      if (mimeType.startsWith('image/')) return 'image';
      if (mimeType.startsWith('video/')) return 'video';
      if (mimeType.startsWith('audio/')) return 'audio';
      return 'document';
    }

    // Get emoji icon for file type
    function getFileIcon(mimeType) {
      if (mimeType.startsWith('image/')) return 'üñºÔ∏è';
      if (mimeType.startsWith('video/')) return 'üé¨';
      if (mimeType.startsWith('audio/')) return 'üéµ';
      if (mimeType.includes('pdf')) return 'üìï';
      return 'üìÑ';
    }

    // Format file size
    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Create a message DOM element (used by both history and real-time)
    function createMessageElement(msg) {
      const msgDiv = document.createElement('div');
      const msgDirection = msg.direction ? msg.direction.toLowerCase() : 'unknown';
      msgDiv.className = `message ${msgDirection}`;
      if (msg.id) {
        msgDiv.setAttribute('data-message-id', msg.id);
      }

      const media = msg.media;

      // ‚îÄ‚îÄ Location ‚îÄ‚îÄ
      if (media && media.type === 'location') {
        const locDiv = document.createElement('div');
        locDiv.className = 'message-location';
        const mapsUrl = media.mapsUrl || `https://maps.google.com/?q=${media.latitude},${media.longitude}`;
        const link = document.createElement('a');
        link.href = mapsUrl;
        link.target = '_blank';
        link.rel = 'noopener';

        // Static map image (OpenStreetMap tile as free fallback)
        const mapImg = document.createElement('img');
        mapImg.src = `https://staticmap.openstreetmap.de/staticmap.php?center=${media.latitude},${media.longitude}&zoom=15&size=300x150&markers=${media.latitude},${media.longitude},red-pushpin`;
        mapImg.alt = 'Map';
        mapImg.loading = 'lazy';
        link.appendChild(mapImg);

        if (media.name || media.address) {
          const info = document.createElement('div');
          info.className = 'location-info';
          if (media.name) {
            const nameEl = document.createElement('div');
            nameEl.className = 'loc-name';
            nameEl.textContent = media.name;
            info.appendChild(nameEl);
          }
          if (media.address) {
            const addrEl = document.createElement('div');
            addrEl.className = 'loc-address';
            addrEl.textContent = media.address;
            info.appendChild(addrEl);
          }
          link.appendChild(info);
        }

        locDiv.appendChild(link);
        msgDiv.appendChild(locDiv);
      }
      // ‚îÄ‚îÄ Contacts ‚îÄ‚îÄ
      else if (media && media.type === 'contacts') {
        const contactsDiv = document.createElement('div');
        contactsDiv.className = 'message-contacts';
        const contacts = media.contacts || [];
        const maxShow = 10;
        contacts.slice(0, maxShow).forEach(c => {
          const card = document.createElement('div');
          card.className = 'contact-card';
          const avatar = document.createElement('div');
          avatar.className = 'contact-avatar';
          const name = c.name?.formatted_name || c.name?.first_name || 'Unknown';
          avatar.textContent = name.charAt(0).toUpperCase();
          card.appendChild(avatar);
          const nameEl = document.createElement('span');
          nameEl.className = 'contact-name';
          nameEl.textContent = name;
          card.appendChild(nameEl);
          contactsDiv.appendChild(card);
        });
        if (contacts.length > maxShow) {
          const overflow = document.createElement('div');
          overflow.className = 'contacts-overflow';
          overflow.textContent = `+${contacts.length - maxShow} more`;
          contactsDiv.appendChild(overflow);
        }
        msgDiv.appendChild(contactsDiv);
      }
      // ‚îÄ‚îÄ Sticker ‚îÄ‚îÄ
      else if (media && media.type === 'sticker') {
        msgDiv.classList.add('sticker-msg');
        const stickerDiv = document.createElement('div');
        stickerDiv.className = 'message-sticker';
        const img = document.createElement('img');
        img.src = media.url;
        img.alt = 'Sticker';
        img.loading = 'lazy';
        stickerDiv.appendChild(img);
        msgDiv.appendChild(stickerDiv);
      }
      // ‚îÄ‚îÄ Interactive (button/list reply) ‚îÄ‚îÄ
      else if (media && media.type === 'interactive') {
        const intDiv = document.createElement('div');
        intDiv.className = 'message-interactive';
        const label = document.createElement('div');
        label.className = 'interactive-label';
        const iType = media.interactiveType;
        if (iType === 'list_reply') {
          label.textContent = 'List Reply';
        } else {
          label.textContent = 'Button Reply';
        }
        intDiv.appendChild(label);
        const title = document.createElement('div');
        title.className = 'interactive-title';
        title.textContent = media.buttonReply?.title || media.listReply?.title || '';
        intDiv.appendChild(title);
        msgDiv.appendChild(intDiv);
      }
      // ‚îÄ‚îÄ Standard media (image/video/audio/document) ‚îÄ‚îÄ
      else if (media && media.url) {
        const mediaDiv = document.createElement('div');
        mediaDiv.className = 'message-media';

        switch (media.type) {
          case 'image': {
            const img = document.createElement('img');
            img.src = media.url;
            img.alt = 'Image';
            img.loading = 'lazy';
            img.onclick = () => window.open(media.url, '_blank');
            mediaDiv.appendChild(img);
            break;
          }
          case 'video': {
            const video = document.createElement('video');
            video.src = media.url;
            video.controls = true;
            video.preload = 'metadata';
            mediaDiv.appendChild(video);
            break;
          }
          case 'audio': {
            const audio = document.createElement('audio');
            audio.src = media.url;
            audio.controls = true;
            mediaDiv.appendChild(audio);
            break;
          }
          default: {
            const link = document.createElement('a');
            link.href = media.url;
            link.target = '_blank';
            link.className = 'doc-link';
            link.innerHTML = 'üìÑ <span>Download Document</span>';
            mediaDiv.appendChild(link);
          }
        }

        msgDiv.appendChild(mediaDiv);
      }

      // Text / caption (skip for location/contacts/interactive which already have their own display)
      if (msg.text && !(media && (media.type === 'location' || media.type === 'contacts' || media.type === 'interactive'))) {
        const textDiv = document.createElement('div');
        textDiv.className = 'message-text';
        textDiv.textContent = msg.text;
        msgDiv.appendChild(textDiv);
      } else if (!media) {
        // No text and no media ‚Äî show placeholder
        if (msg.text) {
          const textDiv = document.createElement('div');
          textDiv.className = 'message-text';
          textDiv.textContent = msg.text;
          msgDiv.appendChild(textDiv);
        } else {
          const textDiv = document.createElement('div');
          textDiv.className = 'message-text';
          textDiv.textContent = '[Empty message]';
          msgDiv.appendChild(textDiv);
        }
      }

      const metaDiv = document.createElement('div');
      metaDiv.className = 'message-meta';
      const time = new Date(msg.timestamp).toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit'
      });
      metaDiv.textContent = time;

      if (msgDirection === 'outbound') {
        const statusSpan = document.createElement('span');
        statusSpan.className = 'message-status';

        let statusHtml = '‚úì';
        let statusClass = 'status-sent';

        switch (msg.status) {
          case 'read':
            statusHtml = '‚úì‚úì';
            statusClass = 'status-read';
            break;
          case 'delivered':
            statusHtml = '‚úì‚úì';
            statusClass = 'status-delivered';
            break;
          case 'failed':
            statusHtml = '‚ùå';
            statusClass = 'status-failed';
            break;
          case 'sent':
          case 'queued':
          default:
            statusHtml = '‚úì';
            statusClass = 'status-sent';
            break;
        }

        statusSpan.innerHTML = statusHtml;
        statusSpan.classList.add(statusClass);
        metaDiv.appendChild(statusSpan);
      }

      msgDiv.appendChild(metaDiv);

      return msgDiv;
    }

    // Add a message to the UI
    function addMessageToUI(msg) {
      const container = document.getElementById('messagesContainer');
      const emptyState = document.getElementById('emptyState');
      const typingIndicator = document.getElementById('typingIndicator');

      emptyState.style.display = 'none';

      const msgDiv = createMessageElement(msg);
      container.insertBefore(msgDiv, typingIndicator);

      // Scroll to bottom (smoothly for newly added messages)
      scrollToBottom(true);
    }

    // Submit on Enter (Shift+Enter for newline)
    function handleComposeKeydown(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendCustomMessage();
      }
    }

    // Auto-grow textarea
    function autoResize(el) {
      el.style.height = '44px'; // Reset to min height
      const newHeight = Math.min(el.scrollHeight, 120);
      el.style.height = newHeight + 'px';

      // Update scroll button position 
      const inputContainer = document.querySelector('.input-container');
      const scrollBtn = document.getElementById('scrollBottomBtn');
      if (inputContainer && scrollBtn) {
        scrollBtn.style.bottom = `${inputContainer.offsetHeight + 10}px`;
      }
    }

    // Initialize on page load
    window.addEventListener('load', () => {
      initWidget();

      // Setup event listeners
      const messagesContainer = document.getElementById('messagesContainer');
      const scrollBottomBtn = document.getElementById('scrollBottomBtn');

      if (messagesContainer && scrollBottomBtn) {
        messagesContainer.addEventListener('scroll', () => {
          const distanceToBottom = messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight;
          if (distanceToBottom > 150) {
            scrollBottomBtn.classList.add('visible');
          } else {
            scrollBottomBtn.classList.remove('visible');
          }

          // Lazy load trigger: fetch older when scrolling near the top (within 30% of scrollHeight)
          if (messagesContainer.scrollTop <= messagesContainer.scrollHeight * 0.3) {
            fetchOlderMessages();
          }
        });

        scrollBottomBtn.addEventListener('click', () => {
          scrollToBottom(true);
        });
      }

      // Observer to handle dynamically loaded images affecting scroll
      if (messagesContainer) {
        const resizeObserver = new ResizeObserver(entries => {
          for (let entry of entries) {
            if (entry.target.nodeName === 'IMG') {
              const distanceToBottom = messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight;
              if (distanceToBottom <= 250) {
                scrollToBottom();
              }
            }
          }
        });

        const mutationObserver = new MutationObserver(mutations => {
          mutations.forEach(mutation => {
            mutation.addedNodes.forEach(node => {
              if (node.nodeType === 1) { // ELEMENT_NODE
                if (node.nodeName === 'IMG') {
                  resizeObserver.observe(node);
                }
                const imgs = node.querySelectorAll('img');
                imgs.forEach(img => resizeObserver.observe(img));
              }
            });
          });
        });

        mutationObserver.observe(messagesContainer, { childList: true, subtree: true });
      }

      const removeBtn = document.getElementById('removeAttachBtn');
      if (removeBtn) removeBtn.addEventListener('click', removeAttachment);

      const fileInput = document.getElementById('fileInput');
      if (fileInput) fileInput.addEventListener('change', handleFileSelect);

      const attachBtn = document.getElementById('attachBtn');
      if (attachBtn) attachBtn.addEventListener('click', () => {
        document.getElementById('fileInput').click();
      });

      const customInput = document.getElementById('customMessageInput');
      if (customInput) {
        customInput.addEventListener('keydown', handleComposeKeydown);
        customInput.addEventListener('input', function () {
          autoResize(this);
        });
      }

      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) sendBtn.addEventListener('click', sendCustomMessage);
    });
    window.addEventListener('unload', () => {
      stopPolling();
      if (socket) socket.disconnect();
    });
  </script>
</body>

</html>