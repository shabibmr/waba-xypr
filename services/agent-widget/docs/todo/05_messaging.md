# Task 05 — Message Send Flow, Status Indicators & Retry

**Priority:** HIGH — core functional requirement
**Depends on:** 01_foundation (API paths), 03_websockets (status via socket), 04_react_frontend (UI)
**Blocks:** 08_media (extends send flow with file upload)

---

## Gap Summary

| FRD Requirement | Current State | Status |
|----------------|---------------|--------|
| `POST /api/v1/widget/send` — validates, publishes to RabbitMQ | No `/send` endpoint; only `/send-template` and `/send-quick-reply` which call whatsapp-api directly | ❌ Wrong architecture |
| Optimistic UI: message shows as "pending" before confirmation | No optimistic UI | ❌ Missing |
| Status: `sent` (1 gray tick), `delivered` (2 gray), `read` (2 blue) | No status display | ❌ Missing |
| Retry on failure: 3 retries (100ms, 200ms, 400ms backoff) | No retry logic | ❌ Missing |
| `messageId` for deduplication | No dedup | ❌ Missing |
| Retry button on failed messages | No retry button | ❌ Missing |
| Text send uses unique messageId | No unique ID generated by frontend | ❌ Missing |
| `mediaUrl` optional in send payload | No media upload support yet | ❌ Missing (see 08) |
| `integrationId` required in send payload | Not included | ❌ Missing |

---

## Tasks

### T5.1 — Add `POST /api/v1/widget/send` Endpoint

**File:** `src/routes/widget.routes.js`

```javascript
router.post('/send', widgetController.sendMessage);
```

**File:** `src/controllers/widget.controller.js`

```javascript
async sendMessage(req, res, next) {
  try {
    const { conversationId, tenantId, text, mediaUrl, integrationId } = req.body;
    const resolvedTenantId = tenantId || req.headers['x-tenant-id'];

    if (!conversationId) return res.status(400).json({ error: { message: 'conversationId required', code: 'MISSING_FIELD' } });
    if (!resolvedTenantId) return res.status(400).json({ error: { message: 'tenantId required', code: 'MISSING_FIELD' } });
    if (!integrationId) return res.status(400).json({ error: { message: 'integrationId required', code: 'MISSING_FIELD' } });
    if (!text && !mediaUrl) return res.status(400).json({ error: { message: 'text or mediaUrl required', code: 'MISSING_FIELD' } });

    const result = await widgetService.sendMessage({
      conversationId,
      tenantId: resolvedTenantId,
      text,
      mediaUrl,
      integrationId,
    });

    res.json({ success: true, messageId: result.messageId });
  } catch (err) {
    next(err);
  }
}
```

**File:** `src/services/widget.service.js`

```javascript
async sendMessage({ conversationId, tenantId, text, mediaUrl, integrationId }) {
  // 1. Resolve wa_id from state-manager
  const context = await this.resolveContext(conversationId, tenantId);
  const waId = context.wa_id;

  // 2. Build payload
  const messageId = generateMessageId(); // see T5.2
  const payload = {
    messageId,
    conversationId,
    tenantId,
    waId,
    integrationId,
    text,
    mediaUrl: mediaUrl || null,
  };

  // 3. Send to whatsapp-api-service
  const response = await this.axiosClient.post('/whatsapp/send/text', payload, {
    headers: { 'X-Tenant-ID': tenantId },
  });

  return { messageId: response.data.messageId || messageId };
}
```

---

### T5.2 — Message ID Generation (Deduplication)

**New file:** `src/utils/generateId.js`

```javascript
const { randomUUID } = require('crypto');

function generateMessageId() {
  return `msg_${Date.now()}_${randomUUID().slice(0, 8)}`;
}

module.exports = { generateMessageId };
```

Use `messageId` in:
- Outbound messages sent to whatsapp-api-service
- Optimistic UI state on frontend
- Dedup check: if socket emits duplicate `status_update` for same `messageId`, ignore

---

### T5.3 — Retry Logic with Exponential Backoff

**New file:** `src/utils/retry.js`

```javascript
async function retryWithBackoff(fn, maxAttempts = 3, delaysMs = [100, 200, 400]) {
  let lastError;
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (err) {
      lastError = err;
      if (attempt < maxAttempts - 1) {
        await sleep(delaysMs[attempt] || delaysMs[delaysMs.length - 1]);
      }
    }
  }
  throw lastError;
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

module.exports = { retryWithBackoff };
```

**Use in widget.service.js:**

```javascript
const { retryWithBackoff } = require('../utils/retry');

async sendMessage(payload) {
  return retryWithBackoff(() => this._doSend(payload));
}
```

---

### T5.4 — Frontend: Optimistic Message State (React)

**New file:** `src/client/hooks/useMessages.js`

```javascript
import { useState, useEffect, useCallback } from 'react';
import { fetchHistory } from '../services/widgetApi';
import { useSocket } from './useSocket';

export function useMessages(conversationId, tenantId) {
  const [messages, setMessages] = useState([]);
  const { socket } = useSocket(tenantId, conversationId);

  // Load initial history
  useEffect(() => {
    fetchHistory(conversationId, tenantId).then(data => {
      setMessages(data.messages || []);
    });
  }, [conversationId, tenantId]);

  // Real-time inbound
  useEffect(() => {
    if (!socket) return;
    const onInbound = (data) => {
      setMessages(prev => {
        // Dedup by messageId
        if (prev.some(m => m.id === data.messageId)) return prev;
        return [...prev, {
          id: data.messageId || Date.now().toString(),
          direction: 'inbound',
          text: data.text,
          mediaUrl: data.mediaUrl,
          timestamp: data.timestamp || new Date(),
          status: null,
        }];
      });
    };
    socket.on('inbound_message', onInbound);
    return () => socket.off('inbound_message', onInbound);
  }, [socket]);

  // Status updates
  useEffect(() => {
    if (!socket) return;
    const onStatus = ({ messageId, status }) => {
      setMessages(prev => prev.map(m => m.id === messageId ? { ...m, status } : m));
    };
    socket.on('status_update', onStatus);
    return () => socket.off('status_update', onStatus);
  }, [socket]);

  const addMessage = useCallback((msg) => {
    setMessages(prev => {
      if (prev.some(m => m.id === msg.id)) return prev;
      return [...prev, msg];
    });
  }, []);

  const updateStatus = useCallback((messageId, status) => {
    setMessages(prev => prev.map(m => m.id === messageId ? { ...m, status } : m));
  }, []);

  const markFailed = useCallback((messageId) => {
    setMessages(prev => prev.map(m => m.id === messageId ? { ...m, status: 'failed' } : m));
  }, []);

  return { messages, addMessage, updateStatus, markFailed };
}
```

---

### T5.5 — Frontend: Retry Button for Failed Messages

**File:** `src/client/components/MessageList.jsx`

```jsx
{msg.status === 'failed' && (
  <button
    className="retry-btn"
    onClick={() => onRetry(msg)}
    aria-label="Retry sending message"
  >
    ↺ Retry
  </button>
)}
```

Pass `onRetry` prop from `InputBox` or a parent context.

---

### T5.6 — Frontend: useSocket Hook

**New file:** `src/client/hooks/useSocket.js`

```javascript
import { useState, useEffect, useRef } from 'react';
import { io } from 'socket.io-client';

const API_BASE_URL = window.__WIDGET_CONFIG__?.apiUrl || window.location.origin;

export function useSocket(tenantId, conversationId) {
  const [connected, setConnected] = useState(false);
  const socketRef = useRef(null);

  useEffect(() => {
    if (!tenantId || !conversationId) return;

    const token = getToken();
    const socket = io(API_BASE_URL, {
      auth: { token },
      query: { tenantId, conversationId },
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: Infinity,
    });

    socket.on('connect', () => setConnected(true));
    socket.on('disconnect', () => setConnected(false));

    socketRef.current = socket;

    return () => {
      socket.disconnect();
      socketRef.current = null;
    };
  }, [tenantId, conversationId]);

  return { socket: socketRef.current, connected };
}

function getToken() {
  const p = new URLSearchParams(window.location.search);
  return p.get('token') || localStorage.getItem('session_token') || '';
}
```

---

### T5.7 — Widget API Client (Frontend)

**New file:** `src/client/services/widgetApi.js`

```javascript
const BASE = window.__WIDGET_CONFIG__?.apiUrl || '';

function getHeaders(tenantId) {
  const token = getToken();
  return {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`,
    'X-Tenant-ID': tenantId,
  };
}

export async function resolveContext(conversationId, tenantId) {
  const res = await fetch(`${BASE}/api/v1/widget/context/${conversationId}`, {
    headers: getHeaders(tenantId),
  });
  if (!res.ok) throw new Error('InvalidConversation');
  return res.json();
}

export async function fetchHistory(conversationId, tenantId, limit = 20, offset = 0) {
  const res = await fetch(
    `${BASE}/api/v1/widget/conversation/${conversationId}/history?limit=${limit}&offset=${offset}`,
    { headers: getHeaders(tenantId) }
  );
  return res.json();
}

export async function sendMessage({ conversationId, tenantId, waId, text, mediaUrl, integrationId }) {
  const res = await fetch(`${BASE}/api/v1/widget/send`, {
    method: 'POST',
    headers: getHeaders(tenantId),
    body: JSON.stringify({ conversationId, tenantId, text, mediaUrl, integrationId }),
  });
  if (!res.ok) {
    const err = await res.json();
    throw new Error(err.error?.message || 'Send failed');
  }
  return res.json();
}

function getToken() {
  const p = new URLSearchParams(window.location.search);
  return p.get('token') || localStorage.getItem('session_token') || '';
}
```

---

## Acceptance Criteria

- [ ] `POST /api/v1/widget/send` with `{ conversationId, tenantId, text, integrationId }` returns `{ success: true, messageId }`
- [ ] Missing `conversationId`, `tenantId`, or `integrationId` returns 400 with error code
- [ ] Failed send retries 3 times with 100ms/200ms/400ms delays
- [ ] Optimistic message appears immediately in UI with `pending` status
- [ ] Status updates (sent/delivered/read) update tick display in real time via socket
- [ ] Failed message shows Retry button
- [ ] All messages have unique `messageId`; duplicate socket events are ignored
